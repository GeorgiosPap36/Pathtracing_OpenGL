#version 430

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const int RAYS_PER_PIXEL = 5;
const int MAX_DEPTH = 10;
const vec3 BG_COLOR = vec3(0);

const float EPSILON = 0.00001;

const float MAX_INT = 4294967295.0f;

/*------------*
|   STRUCTS   |
*-------------*/

struct Material {
    vec3 color;
    float smoothness; 
    vec3 emissionColor;
    float emissionStrength;
    vec3 absorption;
    float absorptionStrength;
    float refractionProbability;
    float refractionIndex;
}; 

struct Sphere {
    vec3 center;    
    float radius;
    Material material;
};

struct Vertex {
    vec3 pos;
    vec3 normal;
};

struct BVHNode {
    vec3 minVertPos;
    int firstFaceIndex;
    vec3 maxVertPos;
    int lastFaceIndex;
    bool isLeaf;
    int missIndex;
};

struct ModelInfo {
    int vertexCount;
    int indexCount;
    int materialIndex;
    int bvhNodeFirstIndex;
    int bvhNodeLastIndex;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitInfo {
    bool hit;
    float dist;
    vec3 point;
    vec3 normal;
    bool isBackFace;
    Material material;
};

/*--------------------*
|  USER DEFINED DATA  |
*---------------------*/

layout(rgba32f, binding = 0) uniform image2D thisFrame;
layout(rgba32f, binding = 1) uniform image2D lastFrame;

layout(std430, binding = 2) buffer Spheres {
    Sphere spheres[];
};

layout(std430, binding = 3) buffer Vertices {
    Vertex vertices[];
};

layout(std430, binding = 4) buffer Indices {
    ivec4 indices[];
};

layout(std430, binding = 5) buffer Materials {
    Material materials[];
};

layout(std430, binding = 6) buffer BVHNodes {
    BVHNode bvhNodes[];
};

layout(std430, binding = 7) buffer ModelInfos {
    ModelInfo modelInfos[];
};

uniform mat4 viewMatrix;
uniform vec3 cameraPosition;

uniform int width;
uniform int height;

uniform int numberOfSpheres;
uniform int numberOfModels;

uniform int frameCounter;
uniform bool accumulateFrames;

/*------------*
|  FUNCTIONS  |
*-------------*/

float randomValue(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}

vec3 randomUnitVector(inout uint state) {
    float z = randomValue(state) * 2.0f - 1.0f;
    float a = randomValue(state) * 6.2831;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

vec2 getUV(ivec2 id, inout uint state) {
    float aspectRatio = float(width) / float(height);
    return vec2(((float(id.x + randomValue(state)) / float(width)) * 2.0 - 1.0) * aspectRatio,
                (float(id.y + randomValue(state)) / float(height)) * 2.0 - 1.0);
}

HitInfo raySphereIntersection(Ray r, Sphere sphere) {
    HitInfo hitInfo;
    hitInfo.hit = false;
    hitInfo.isBackFace = false;

    vec3 center = sphere.center;
    float radius = sphere.radius;

    vec3 oc = center - r.origin;
    float a = dot(r.direction, r.direction);
    float b = -2.0f * dot(r.direction, oc);
    float c = dot(oc, oc) - radius*radius;
    float d = b * b - 4.0f * a * c;
    if (d >= 0) {
        float tNear = max(0.0, (-b - sqrt(d)) / (2.0f * a));
        float tFar = (-b + sqrt(d)) / (2.0f * a);
        if (tFar > 0.0f) {
            hitInfo.hit = true;

            bool isInside = tNear == 0;

            hitInfo.dist = isInside ? tFar : tNear;

            vec3 spherePoint = r.origin + hitInfo.dist * r.direction;
            vec3 sphereNormal = normalize(spherePoint - center) * (isInside ? -1 : 1);
             
            hitInfo.point = spherePoint;
            hitInfo.normal = sphereNormal;
            hitInfo.material = sphere.material;

            hitInfo.isBackFace = isInside;
        }
    }

    return hitInfo;
}

HitInfo rayTriangleIntersection(Ray r, Vertex t1, Vertex t2, Vertex t3, int modelIndex) {
    HitInfo hitInfo;
    hitInfo.hit = false;

    vec3 c1 = -r.direction;
    vec3 c2 = t2.pos - t1.pos;
    vec3 c3 = t3.pos - t1.pos;
    vec3 c = r.origin - t1.pos;

    vec3 n = cross(c2, c3);
    vec3 e = cross(c1, c);
    float d = dot(c1, n); 

    float t = dot(c, n) / d;
    float u2 =  dot(c3, e) / d;
    float u3 = dot(-c2, e) / d;

    if (u2 < 0 || u3 < 0 || u2 + u3 > 1) {
        return hitInfo;
    }

    if (t > EPSILON) {
        hitInfo.hit = true;
        hitInfo.dist = t;
        hitInfo.point = r.origin + t * r.direction;

        float u1 = 1.0f - u2 - u3;
        vec3 pointNormal = normalize(u1 * t1.normal + u2 * t2.normal + u3 * t3.normal);
        hitInfo.normal = pointNormal;

        if (dot(r.direction, hitInfo.normal) > 0) {
            hitInfo.normal = -hitInfo.normal;
        }

        hitInfo.isBackFace = d < 0;

        hitInfo.material = materials[modelIndex];
    }
    return hitInfo;
}

bool rayAABBIntersection(Ray ray, vec3 minVertPos, vec3 maxVertPos) {
    float tx1 = (minVertPos.x - ray.origin.x) / ray.direction.x;
    float tx2 = (maxVertPos.x - ray.origin.x) / ray.direction.x;
    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);
    float ty1 = (minVertPos.y - ray.origin.y) / ray.direction.y; 
    float ty2 = (maxVertPos.y - ray.origin.y) / ray.direction.y;
    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));
    float tz1 = (minVertPos.z - ray.origin.z) / ray.direction.z;
    float tz2 = (maxVertPos.z - ray.origin.z) / ray.direction.z;
    tmin = max(tmin, min(tz1, tz2));
    tmax = min(tmax, max(tz1, tz2));
    return tmax >= tmin && tmax > 0;;
}

HitInfo traverseBVH(Ray ray, int firstBvhNodeIndex, int lastBvhNodeIndex, int modelIndex, int vertexOffset) {
    HitInfo closestHitInfo;
    closestHitInfo.hit = false;
    closestHitInfo.dist = MAX_INT;

    bool isLeaf;
    int missIndex;
    vec3 minVertPos;
    vec3 maxVertPos;
    int firstFaceIndex;
    int lastFaceIndex;

    int i = firstBvhNodeIndex;
    while (i >= 0 && i <= lastBvhNodeIndex) {
        isLeaf = bvhNodes[i].isLeaf;
        missIndex = bvhNodes[i].missIndex;
        minVertPos = bvhNodes[i].minVertPos;
        maxVertPos = bvhNodes[i].maxVertPos;
        firstFaceIndex = bvhNodes[i].firstFaceIndex;
        lastFaceIndex = bvhNodes[i].lastFaceIndex;

        if (!rayAABBIntersection(ray, minVertPos, maxVertPos)) {
            i = missIndex;
            continue;
        }

        if (isLeaf) {
            for (int j = firstFaceIndex; j <= lastFaceIndex; j++) {
                Vertex t1 = vertices[indices[j].x + vertexOffset];
                Vertex t2 = vertices[indices[j].y + vertexOffset];
                Vertex t3 = vertices[indices[j].z + vertexOffset];

                HitInfo hitInfo = rayTriangleIntersection(ray, t1, t2, t3, modelIndex);
                if (hitInfo.hit && hitInfo.dist < closestHitInfo.dist) {
                    closestHitInfo = hitInfo;
                }
            }
        }

        i++;
        
    }

    return closestHitInfo;
}

HitInfo findFirstIntersection(Ray ray) {
    HitInfo closestHitInfo;
    closestHitInfo.hit = false;
    closestHitInfo.dist = MAX_INT;

    for (int i = 0; i < numberOfSpheres; i++) {
        HitInfo hitInfo = raySphereIntersection(ray, spheres[i]);
        if (hitInfo.hit && hitInfo.dist < closestHitInfo.dist) {
            closestHitInfo = hitInfo;
        }
    }

    int vertexOffset = 0;

    for (int i = 0; i < numberOfModels; i++) {

        HitInfo hitInfo = traverseBVH(ray, modelInfos[i].bvhNodeFirstIndex, modelInfos[i].bvhNodeLastIndex, i, vertexOffset);
        if (hitInfo.hit && hitInfo.dist < closestHitInfo.dist) {
            closestHitInfo = hitInfo;
        }

        vertexOffset += modelInfos[i].vertexCount;
    }

    return closestHitInfo;
}

Ray createRay(vec2 uv) {
    Ray ray;
    ray.origin = cameraPosition;

    vec4 worldDir = inverse(viewMatrix) * vec4(uv, -1, 0);
    ray.direction = normalize(worldDir.xyz);

    return ray;
}

vec3 getDiffuseDirection(vec3 surfaceNormal, inout uint rngState) {
    return normalize(surfaceNormal + randomUnitVector(rngState));
}

vec3 getReflectionDirection(vec3 rayDir, vec3 surfaceNormal) {
    return normalize(rayDir - 2 * surfaceNormal * dot(surfaceNormal, rayDir));
}

vec3 getRefractionDirection(vec3 rayDir, vec3 surfaceNormal, float ri) {
    float cosTheta = min(-dot(rayDir, surfaceNormal), 1.0);
    vec3 rOutPerpendicular =  ri * (rayDir + cosTheta * surfaceNormal);
    float perpLength = length(rOutPerpendicular);
    vec3 rOutParallel = -sqrt(abs(1.0 - perpLength * perpLength)) * surfaceNormal;
    return rOutPerpendicular + rOutParallel;
}

// Schlick's approximation
float reflectance(float cosine, float riIn, float riOut) {
    float r0 = (riIn - riOut) / (riIn + riOut);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow((1 - cosine), 5);
}

vec3 reflectOrRefract(Ray ray, HitInfo hitInfo, inout uint rngState) {

    float refractionIndexBefore = hitInfo.isBackFace ? hitInfo.material.refractionIndex : 1.0;
    float refractionIndexAfter = hitInfo.isBackFace ? 1.0 : hitInfo.material.refractionIndex;

    float refRatio = refractionIndexBefore / refractionIndexAfter;

    float cosTheta = clamp(dot(-ray.direction, hitInfo.normal), -1.0, 1.0);
    float sinTheta = max(0.0, sqrt(1.0 - cosTheta * cosTheta));

    bool cannotRefract = refRatio * sinTheta > 1.0;
    
    vec3 direction;
    if (cannotRefract || reflectance(cosTheta, refractionIndexBefore, refractionIndexAfter) > randomValue(rngState)) {
        vec3 diffuseDir = getDiffuseDirection(hitInfo.normal, rngState);
        vec3 reflectDir = getReflectionDirection(ray.direction, hitInfo.normal);
        direction = mix(diffuseDir, reflectDir, hitInfo.material.smoothness);
    } else {
        direction = getRefractionDirection(ray.direction, hitInfo.normal, refRatio);
    }

    return normalize(direction);
}
 
vec3 trace(Ray ray, inout uint rngState) {
    HitInfo hitInfo;
    Material mat;

    vec3 color = vec3(1);
    vec3 radiance = vec3(0);

    for (int i = 0; i < MAX_DEPTH; i++) {
        hitInfo = findFirstIntersection(ray);
        mat = hitInfo.material;

        if (!hitInfo.hit) {
            break;
        }

        if (mat.refractionProbability > 0) {
            // Beer's Law
            if (hitInfo.isBackFace) {
                color *= exp(-hitInfo.dist * mat.absorption * mat.absorptionStrength);
            }

            ray.direction = reflectOrRefract(ray, hitInfo, rngState);
            ray.origin = hitInfo.point + hitInfo.normal * EPSILON * sign(dot(hitInfo.normal, ray.direction));

        } else {
            radiance += color * mat.emissionColor * mat.emissionStrength;
            color *= mat.color;

            ray.origin = hitInfo.point + hitInfo.normal * EPSILON;
            ray.direction = mix(getDiffuseDirection(hitInfo.normal, rngState), 
                                getReflectionDirection(ray.direction, hitInfo.normal), 
                                mat.smoothness);
        }

        float p = clamp(max(color.x, max(color.y, color.z)), 0.05, 1.0);
        if (i > 2 && p < randomValue(rngState)) {
            break;
        }

        color /= p;
    }

    return radiance;
}


/*------------*
|     MAIN    |
*-------------*/

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    if (id.x >= width || id.y >= height) {
        return;
    }

    uint pixelIndex = id.y * width + id.x;
    uint rngState = pixelIndex;

    if (accumulateFrames) {
        rngState += 1236546 * frameCounter;
    }

    Ray ray;
    vec2 uv = getUV(id, rngState);
    int depth = 0;

    vec3 color = vec3(0, 0, 0);
    for (int i = 0; i < RAYS_PER_PIXEL; i++) {
        ray = createRay(uv);
        color += trace(ray, rngState);
    }
    color = color / RAYS_PER_PIXEL;

    if (accumulateFrames) {
        vec3 prev = imageLoad(lastFrame, id).rgb;
        color = mix(prev, color, 1.0 / float(frameCounter + 1));
    }
    
    imageStore(thisFrame, id, vec4(color, 1.0));
}